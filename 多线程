## 多线程有什么好处

榨取CPU资源以达到快如闪电

## 线程该如何创建

> 继承Thread
>
> 实现Runable
>
> 实现Callable并传入到FutureTask
>
> 线程池Executor获取

## 线程的生命周期

### 出生

> NEW

### 存在

> 可执行
>
> ​	RUNNABLE

> 不可执行,即挂起
>
> ​	BLOCKED,WAITING,TIMED_WAITING

### 死亡

> TERMINATED

## 线程的操作

> 1. 挂起
>
>    wait
>
> 2. 唤醒
>
>    notify
>
>    notifyAll
>
> 3. 中断
>
>    interrupt

## 关于线程上下文

### 线程上下文切换是咋做的

1. 保护当前线程案发现场
2. 调度新的线程

### 如何减少上下文切换

1. 无锁并发编程---ID按照Hash取模,不同线程各行其道
2. 使用Atomic的CAS算法
3. 使用最少线程
4. 使用协程可以实现但线程多任务调度和切换

## 多线程亟待解决的问题

### 线程死锁如何锁定

> 命令模式锁定
>
> ​	jps---->jstat
>
> 视图模式锁定
>
> ​	jconsole

### 线程安全

#### 什么是线程安全

不论如何执行都能符合预期的幂等性

### 线程不安全成因

对共享资源进行非原子性操作或无序操作

### 如何保证线程安全

1. 多线程改单线程

2. 不操作共享资源

   | 操作方法         |
   | ---------------- |
   | 不共享           |
   | 操作独享区域TLAB |
   | 操作无状态变化   |
   | 操作不可变对象   |

3. 操作Atomic原子操作类

4. 保证操作的原子性操作

   **加锁**

| 锁的分类         | 解释                                    |
| ---------------- | --------------------------------------- |
| 自旋锁           | 自旋空等待而不挂起,自旋到特定条件才挂起 |
| 阻塞锁           |                                         |
| 重入锁           |                                         |
| 共享锁vs读写锁   | 读写锁:读读共享,其他不共享              |
| 互斥锁vs独占锁   |                                         |
| 悲观锁vs乐观锁   |                                         |
| 公平锁vs非公平锁 |                                         |
| 偏向锁           |                                         |

​	**锁的实现**

> SYNC
>
> 1. 托管给jvm操作
> 2. JDK1.6后的优化
>    - 锁只能升级不能降级
>      - 无锁
>      - 偏向锁
>      - 轻量级锁:通过CAS消除同步互斥
>      - 重量级锁
>    - 其他锁优化特性
>      - 锁消除:不可能存在共享数据竞争的锁进行消除
>      - 锁粗化:将连续的加锁精简到只加一次锁
>      - 自旋锁:减少上下文切换而进行自旋空等待

> Lock
>
> 1. 底层原理
>    - CAS确保状态
>    - AQS确保有序队列
> 2. 实现
>    - ReentrantLock
>    - ReentrantReadWriteLock
>      - 锁降级:写锁获取---> 获取读锁---> 释放写锁---> 释放读锁
>      - 注意点1:写锁要明示释放,锁降级之后不会直接降级成读锁,不会随着读锁的释放而释放
>      - 注意点2:不能锁升级
>    - StampedLock
>      - 优点
>        - 支持锁升级和锁降级
>        - 支持乐观读和悲观读
>        - 有限次数的自旋
>      - 缺点

## 关于单例

| 设计模式             | 线程安全与否            |
| -------------------- | ----------------------- |
| 饿汉式-静态常量      | 线程安全,大对象时效率低 |
| 饿汉式-静态代码块    | 线程安全,大对象时效率低 |
| 懒汉式-不加锁        | 线程不安全              |
| 懒汉式-同步方法      | 线程安全,但效率低       |
| 懒汉式-同步new代码块 | 线程不安全              |
| 懒汉式-双重检查DCL   | 线程安全                |
| 懒汉式-静态内部类    | 线程安全                |
| 懒汉式-枚举          | 线程安全                |

## 并发工具类

1. CountDownLatch

   分而治之后进行结果累计

2. CyclicBarrier

   达到公共障碍点后继续进行

3. Semaphore

   控制并发数量---->接口限流

4. Exchanger

   同步点交换数据

## 线程通信

> 通过共享内存（堆与离堆）实现的隐式通信
>
> 通过消息传递（wait，notify，notifyall）的显式通信

